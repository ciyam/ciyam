`{`@eq`(`'includes`'`,`$section`)\
// [(start for_schedule)]
#include "ttime_helper.h"
#include "numeric_helper.h"
#include "`{`$module_name`}_`{`$arg_eclass`}.h"
#include "`{`$module_name`}_`{`$arg_gclass`}.h"
#include "`{`$module_name`}_`{`$arg_ogclass`}.h"
`{`$fpclasses`=`'`'`}\
`{`?`$arg_field_list`[`$arg_field_list`%,`,\
`{`!`@eq`(`'\\2`'`,`'`'`)`$fpclasses`=`$fpclasses`+`'\\2`'`}`]`}\
`{`[`$fpclasses`,#include "`{`$module_name`}_\\$.h"`+\n`]`}
// [(finish for_schedule)]
`}
`{`@eq`(`'anonymous`'`,`$section`)\
// [(start for_schedule)]
void create_from_source( int child_num,
 const date_time& dt, class_pointer< `{`$module_name`}_`{`$arg_eclass`} >& cp_event, const string& group,
 const `{`$module_name`}_`{`$arg_iclass`}& source, const `{`$module_name`}_`{`$arg_class`}& schedule, bool& has_overlapping )
{
`{`@eq`(`$arg_igroupfield`,`'`'`)\
   ( void )group;

`}\
   string child_key( construct_key_from_int( dt.as_string( ), child_num ) );
   cp_event->op_create( child_key );

   cp_event->`{`$arg_ewhenfield`}( dt );
   cp_event->`{`$arg_eschedfield`}( schedule.get_key( ) );
   cp_event->`{`$arg_esifield`}( source );
   cp_event->`{`$arg_estatfield`}( schedule.`{`$arg_rstatfield`}( ) );
`{`!`@eq`(`$arg_iuserfield`,`'`'`)`&`!`@eq`(`$arg_usrfield`,`'`'`)
   cp_event->`{`$arg_iuserfield`}( source.`{`$arg_usrfield`}( ) );\
`}
`{`!`@eq`(`$arg_igroupfield`,`'`'`)
   cp_event->`{`$arg_igroupfield`}( group );\
`}`{`!`@eq`(`$arg_etzabbrfield`,`'`'`)`&`!`@eq`(`$arg_tzfield`,`'`'`)

   cp_event->`{`$arg_etzabbrfield`}( schedule.`{`$arg_tzfield`}( ).`{`$arg_tzabbrfield`}( ) );\
`}
`{`!`@eq`(`$arg_edurfield`,`'`'`)`&`!`@eq`(`$arg_idurationfield`,`'`'`)
   cp_event->`{`$arg_edurfield`}( source.`{`$arg_idurationfield`}( ) );
`}
`{`?`$arg_field_list`[`$arg_field_list`%,`,\
   cp_event->\\0( source.\\1( ) );
`]`}
   cp_event->op_apply( );

   has_overlapping = false;
`{`!`@eq`(`$arg_idurationfield`,`'`'`)`&`!`@eq`(`$arg_eoverfield`,`'`'`)
   if( source.`{`$arg_idurationfield`}( ) > 0 )
   {
      cp_event->perform_fetch( );
      if( cp_event->`{`$arg_eoverfield`}( ) )
         has_overlapping = true;
   }\
`}
}

bool is_excluded( const date_time& dt, const vector< pair< date_time, date_time > >& exclusions )
{
   bool excluded = false;
   for( size_t i = 0; i < exclusions.size( ); i++ )
   {
      if( dt >= exclusions[ i ].first && dt <= exclusions[ i ].second )
      {
         excluded = true;
         break;
      }
   }

   return excluded;
}

bool is_scheduled( const `{`$module_name`}_`{`$arg_iclass`}& source,
 date_time& dt, const vector< pair< date_time, date_time > >& exclusions )
{
   bool okay = true;

   if( !source.`{`$arg_iignorexfield`}( ) )
   {
      switch( source.`{`$arg_ionexfield`}( ) )
      {
         case 0: // i.e. Do_Not_Schedule
         if( is_excluded( dt, exclusions ) )
            okay = false;
         break;

         case 1: // i.e. Use_Next_Available_Day
         while( is_excluded( dt, exclusions ) )
            dt += ( days )1;
         break;

         case 2: // i.e. Use_Next_Available_Weekday
         if( is_excluded( dt, exclusions ) )
         {
            do
            {
               dt += ( days )1;
            } while( is_excluded( dt, exclusions ) || dt.is_weekend_day( ) );
         }
         break;

         case 3: // i.e. Use_Previous_Available_Day
         while( is_excluded( dt, exclusions ) )
            dt -= ( days )1;
         break;

         case 4: // i.e. Use_Previous_Available_Weekday
         if( is_excluded( dt, exclusions ) )
         {
            do
            {
               dt -= ( days )1;
            } while( is_excluded( dt, exclusions ) || dt.is_weekend_day( ) );
         }
         break;

         default:
         throw runtime_error( "unexpected `{`$arg_ionexfield`} value #" + to_string( source.`{`$arg_ionexfield`}( ) ) );
      }
   }

   return okay;
}
// [(finish for_schedule)]
`}
`{`@eq`(`'chkproc`'`,`$section`)\
   // [(start for_schedule)]
   if( get_obj( ).iterate_forwards( ) )
   {
      date_time dt( date_time( get_dtm( ) ) + ( seconds )get_obj( ).`{`$arg_pdtofield`}( ) );
      do
      {
         string check_status( get_obj( ).`{`$arg_pstatfield`}( ).get_key( ) );

         if( !check_status.empty( ) && check_status != get_obj( ).`{`$arg_ostatfield`}( ).get_key( ) )
         {
            if( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_forwards( ) )
            {
               do
               {
                  if( get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_ewhenfield`}( ) <= dt
                   && get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_estatfield`}( ) == check_status )
                  {
                      get_obj( ).child_`{`$arg_eventchild`}( ).op_update( );
                      get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_estatfield`}( get_obj( ).`{`$arg_ostatfield`}( ) );
                      get_obj( ).child_`{`$arg_eventchild`}( ).op_apply( );
                  }
               } while( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_next( ) );
            }
         }
      } while( get_obj( ).iterate_next( ) );
   }
   // [(finish for_schedule)]
`}
`{`@eq`(`'conproc`'`,`$section`)\
   // [(start for_schedule)]
   transaction_start( );
   try
   {
      get_obj( ).op_update( );

      int generation_number = get_obj( ).`{`$arg_gnumfield`}( );

      get_obj( ).`{`$arg_gnumfield`}( ++generation_number );

      string key_info( FIELD_ID( `{`$module_name`}, `{`$arg_eclass`}, `{`$arg_gnumfield`} ) );
      key_info += "#1 0";

      if( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_forwards( key_info ) )
      {
         do
         {
            get_obj( ).child_`{`$arg_eventchild`}( ).op_update( );

            if( is_null( get_obj( ).`{`$arg_pstatfield`}( ) ) )
               get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_estatfield`}( get_obj( ).`{`$arg_ostatfield`}( ) );
            else
               get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_estatfield`}( get_obj( ).`{`$arg_pstatfield`}( ) );

            get_obj( ).child_`{`$arg_eventchild`}( ).`{`$arg_gnumfield`}( generation_number );

            get_obj( ).child_`{`$arg_eventchild`}( ).op_apply( );

         } while( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_next( ) );
      }

      get_obj( ).`{`$arg_gffield`}( get_obj( ).`{`$arg_gtfield`}( ) + ( days )1 );

      get_obj( ).`{`$arg_unrevfield`}( false );
      get_obj( ).`{`$arg_actsfield`}( string( c_procedure_id_`{`$arg_genproc`} ) );

      get_obj( ).op_apply( );
      transaction_commit( );
   }
   catch( ... )
   {
      get_obj( ).op_cancel( );
      transaction_rollback( );
      throw;
   }
   // [(finish for_schedule)]
`}
`{`@eq`(`'genproc`'`,`$section`)\
   // [(start for_schedule)]
   transaction_start( );
   try
   {
      get_obj( ).op_update( );

      bool has_overlapping = false;;
      udate ud( get_obj( ).`{`$arg_gffield`}( ) );

      udate last_date_in_range;
      if( get_obj( ).`{`$arg_cycfield`}( ) == 1 )
         last_date_in_range = ud + ( ( days )get_obj( ).`{`$arg_gcfield`}( ) * 7 ) - ( days )1;
      else if( get_obj( ).`{`$arg_cycfield`}( ) == 2 )
         last_date_in_range = ud  + ( ( months )get_obj( ).`{`$arg_gcfield`}( ) ) - ( days )1;
      else if( get_obj( ).`{`$arg_cycfield`}( ) == 3 )
         last_date_in_range = ud + ( ( years )get_obj( ).`{`$arg_gcfield`}( ) ) - ( days )1;

`{`@eq`(`$arg_tzfield`,`'`'`)\
      string tz_abbr = get_tz_abbr( );
`,\
      string tz_abbr = get_obj( ).`{`$arg_tzfield`}( ).`{`$arg_tzabbrfield`}( );
`}
      vector< pair< date_time, date_time > > exclusions;

      `{`$full_class_name`}* p_next( &get_obj( ) );

      while( !is_null( p_next->`{`$arg_exsfield`}( ) ) )
      {
         if( p_next->`{`$arg_exsfield`}( ).child_`{`$arg_eventchild`}( ).iterate_forwards( ) )
         {
            do
            {
               exclusions.push_back( make_pair(
                p_next->`{`$arg_exsfield`}( ).child_`{`$arg_eventchild`}( ).`{`$arg_ewhenfield`}( ),
`{`@eq`(`$arg_efinishfield`,`'`'`)\
                p_next->`{`$arg_exsfield`}( ).child_`{`$arg_eventchild`}( ).`{`$arg_ewhenfield`}( ) ) );
`,\
                p_next->`{`$arg_exsfield`}( ).child_`{`$arg_eventchild`}( ).`{`$arg_efinishfield`}( ) ) );
`}
            } while( p_next->`{`$arg_exsfield`}( ).child_`{`$arg_eventchild`}( ).iterate_next( ) );
         }

         p_next = &p_next->`{`$arg_exsfield`}( );
      }

      class_pointer< `{`$module_name`}_`{`$arg_eclass`} > cp_event( e_create_instance );

      string events_name( cp_event->get_display_name( true ) );

      int cycle = 0;
      int total_cycles( get_obj( ).`{`$arg_gcfield`}( ) );

      if( get_obj( ).`{`$arg_cycfield`}( ) == 2 && ud.get_day( ) > 1 )
      {
         if( ud.get_day( ) > 28 )
            // FUTURE: The error message itself should be a module string.
            throw runtime_error( "Cannot start a monthly generate cycle from a day > 28." );

         ++total_cycles;
      }
      else if( get_obj( ).`{`$arg_cycfield`}( ) == 3 && ( ud.get_month( ) > 1 || ud.get_day( ) > 1 ) )
      {
         if( ud.get_month( ) == 2 && ud.get_day( ) == 29 )
            // FUTURE: The error message itself should be a module string.
            throw runtime_error( "Cannot start a yearly generate cycle from February 29th." );

         ++total_cycles;
      }

      int child_num = 0;
      while( cycle < total_cycles )
      {
         if( get_obj( ).child_`{`$arg_itemchild`}( ).iterate_forwards( ) )
         {
`{`!`@eq`(`$arg_iogchild`,`'`'`)\
            deque< string > other_groups;
            bool processing_other_groups = false;
`}
            do
            {
               if( get_obj( ).`{`$arg_cycfield`}( ) != get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_icycfield`}( ) )
                  throw runtime_error( "unexpected mismatching cycle type for schedule item" );

               ++child_num;

`{`@eq`(`$arg_igroupfield`,`'`'`)\
               string group;
`,\
               string group( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_igroupfield`}( ).get_key( ) );
`}
`{`!`@eq`(`$arg_iogchild`,`'`'`)\
               if( processing_other_groups && !other_groups.empty( ) )
                  group = other_groups[ other_groups.size( ) - 1 ];
`}
               if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_itypfield`}( ) == 1 ) // i.e. Cyclical
               {
                  int occurs_after( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccurfield`}( ) );
                  int recurs_every( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_irecurfield`}( ) );

                  if( cycle >= occurs_after
                   && ( recurs_every == 0 || ( ( cycle + occurs_after ) % recurs_every == 0 ) )
                   && ( ( cycle == 0 && occurs_after == 0 ) || ( recurs_every > 0 || cycle < occurs_after ) ) )
                  {
                     mtime mt( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_itimefield`}( ) );

                     if( get_obj( ).`{`$arg_cycfield`}( ) == 1 ) // i.e. Weekly
                     {
                        int wd = ( int )( weekday )ud;
                        int offset = wd - 1;

                        date_time dt;

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_imonfield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 0 + ( offset > 0 ? ( 7 - offset ) : 0 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ituefield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 1 + ( offset > 1 ? ( 7 - offset ) : offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_iwedfield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 2 + ( offset > 2 ? ( 7 - offset ) : offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ithufield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 3 + ( offset > 3 ? ( 7 - offset ) : offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ifrifield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 4 + ( offset > 4 ? ( 7 - offset ) : offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_isatfield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 5 + ( offset > 5 ? ( 7 - offset ) : offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }
                           
                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_isunfield`}( ) )
                        {
                           dt = date_time( ud + ( days )( 6 + ( offset * -1 ) ), mt );

                           if( exclusions.empty( )
                            || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                              create_from_source( child_num, local_to_utc( dt, tz_abbr ), cp_event,
                               group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                        }
                     }
                     else if( get_obj( ).`{`$arg_cycfield`}( ) == 2 ) // i.e. Monthly
                     {
                        date_time dt;

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idtfield`}( ) == 1 ) // i.e. Specific
                        {
                           dt = date_time( ud.get_year( ),
                            ud.get_month( ), ( day )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idnumfield`}( ), mt );
                        }
                        else if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idtfield`}( ) == 2 ) // i.e. Relative
                        {
                           if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ) < 4 )
                              dt = date_time( ud.get_year( ), ud.get_month( ),
                               ( day_type )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ),
                               ( occurrence )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ), mt );
                           else
                              dt = date_time( ud.get_year( ), ud.get_month( ),
                               ( weekday )( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ) - 3 ),
                               ( occurrence )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ), mt );
                        }

                        bool okay = true;
                        if( ud.get_day( ) > 1 )
                        {
                           if( cycle == 0 )
                           {
                              if( dt.get_day( ) < ud.get_day( ) )
                                 okay = false;
                           }
                           else if( cycle == total_cycles - 1 )
                           {
                              if( dt.get_day( ) >= ud.get_day( ) )
                                 okay = false;
                           }
                        }

                        if( okay && ( exclusions.empty( )
                         || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) ) )
                           create_from_source( child_num, local_to_utc( dt, tz_abbr ),
                            cp_event, group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                     }
                     else if( get_obj( ).`{`$arg_cycfield`}( ) == 3 ) // i.e. Yearly
                     {
                        date_time dt;

                        if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idtfield`}( ) == 1 ) // i.e. Specific
                        {
                           dt = date_time( ud.get_year( ),
                            ( month )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_imonthfield`}( ),
                            ( day )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idomfield`}( ), mt );
                        }
                        else if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idtfield`}( ) == 2 ) // i.e. Relative
                        {
                           if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ) < 4 )
                              dt = date_time( ud.get_year( ),
                               ( month )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_imonthfield`}( ),
                               ( day_type )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ),
                               ( occurrence )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ), mt );
                           else
                              dt = date_time( ud.get_year( ),
                               ( month )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_imonthfield`}( ),
                               ( weekday )( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ) - 3 ),
                               ( occurrence )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ), mt );
                        }
                        else if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idtfield`}( ) == 3 ) // i.e. Customary
                        {
                           switch( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_icustfield`}( ) )
                           {
                              case 1: // i.e. Chinese New Year
                              dt = date_time( ud.get_year( ), e_day_of_significance_chinese_new_year, mt );
                              break;

                              case 2: // i.e. Good Friday
                              dt = date_time( ud.get_year( ), e_day_of_significance_easter_sunday, mt );
                              dt -= ( days )2;
                              break;

                              case 3: // i.e. Easter Saturday
                              dt = date_time( ud.get_year( ), e_day_of_significance_easter_sunday, mt );
                              dt -= ( days )1;
                              break;

                              case 4: // i.e. Easter Sunday
                              dt = date_time( ud.get_year( ), e_day_of_significance_easter_sunday, mt );
                              break;

                              case 5: // i.e. Easter Monday
                              dt = date_time( ud.get_year( ), e_day_of_significance_easter_sunday, mt );
                              dt += ( days )1;
                              break;

                              default:
                              throw runtime_error( "found unexpected customary event vakue #"
                               + to_string( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_icustfield`}( ) ) );
                           }
                        }

                        bool okay = true;
                        if( ud.get_day( ) > 1 || ud.get_month( ) > 1 )
                        {
                           if( cycle == 0 )
                           {
                              if( dt.get_month( ) < ud.get_month( )
                               || ( dt.get_month( ) == ud.get_month( ) && dt.get_day( ) < ud.get_day( ) ) )
                                 okay = false;
                           }
                           else if( cycle == total_cycles - 1 )
                           {
                              if( dt.get_month( ) > ud.get_month( )
                               || ( dt.get_month( ) == ud.get_month( ) && dt.get_day( ) >= ud.get_day( ) ) )
                                 okay = false;
                           }
                        }

                        if( okay && ( exclusions.empty( )
                         || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) ) )
                           create_from_source( child_num, local_to_utc( dt, tz_abbr ),
                            cp_event, group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                     }
                  }
               }
               else if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_itypfield`}( ) == 2 ) // i.e. Whole_Range
               {
                  if( cycle == total_cycles - 1 ) // i.e. only generate these items in the last pass
                  {
                     udate ud;
                     if( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ) <= 4 ) // i.e. First...Fourth
                        ud = udate( get_obj( ).`{`$arg_gffield`}( ) );
                     else // i.e. Last...Fourth_Last
                        ud = last_date_in_range;

                     ud = udate( ud.get_year( ), ud.get_month( ), ud.get_day( ),
                      ( day_type )get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_idcfield`}( ),
                      ( occurrence )( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_ioccfield`}( ) ) );

                     if( ud < get_obj( ).`{`$arg_gffield`}( ) || ud > last_date_in_range )
                        // FUTURE: The error message itself should be a module string.
                        throw runtime_error( get_obj( ).child_`{`$arg_itemchild`}( ).get_display_name( )
                         + " '" + get_obj( ).child_`{`$arg_itemchild`}( ).Description( ) + "' is out of range." );

                     mtime mt( get_obj( ).child_`{`$arg_itemchild`}( ).`{`$arg_itimefield`}( ) );

                     date_time dt( local_to_utc( date_time( ud, mt ), tz_abbr ) );

                     if( exclusions.empty( ) || is_scheduled( get_obj( ).child_`{`$arg_itemchild`}( ), dt, exclusions ) )
                        create_from_source( child_num, dt,
                         cp_event, group, get_obj( ).child_`{`$arg_itemchild`}( ), get_obj( ), has_overlapping );
                  }
               }
`{`!`@eq`(`$arg_iogchild`,`'`'`)\
               if( processing_other_groups )
               {
                  if( !other_groups.empty( ) )
                     other_groups.pop_back( );

                  if( other_groups.empty( ) )
                     processing_other_groups = false;
               }
               else if( get_obj( ).child_`{`$arg_itemchild`}( ).child_`{`$arg_iogchild`}( ).iterate_forwards( ) )
               {
                  processing_other_groups = true;
                  do
                  {
                     string next_group(
                      get_obj( ).child_`{`$arg_itemchild`}( ).child_`{`$arg_iogchild`}( ).`{`$arg_ioggrpfield`}( ).get_key( ) );

                     if( next_group != group )
                        other_groups.push_back( next_group );
                  } while( get_obj( ).child_`{`$arg_itemchild`}( ).child_`{`$arg_iogchild`}( ).iterate_next( ) );
               }
            } while( processing_other_groups ? true : get_obj( ).child_`{`$arg_itemchild`}( ).iterate_next( ) );\
`,\
            } while( get_obj( ).child_`{`$arg_itemchild`}( ).iterate_next( ) );\
`}
         }

         switch( get_obj( ).`{`$arg_cycfield`}( ) )
         {
            case 1:  // i.e. Weekly
            ud += 7;
            break;

            case 2:  // i.e. Monthly
            ud += ( months )1;
            break;

            case 3:  // i.e. Yearly
            ud += ( years )1;
            break;
         }

         ++cycle;
      }

      get_obj( ).`{`$arg_unrevfield`}( true );
      get_obj( ).`{`$arg_actsfield`}( string( c_procedure_id_`{`$arg_conproc`} ) + "," + string( c_procedure_id_`{`$arg_remproc`} ) );

      get_obj( ).`{`$arg_lgffield`}( get_obj( ).`{`$arg_gtffield`}( ) );
      get_obj( ).`{`$arg_lgtfield`}( get_obj( ).`{`$arg_gtfield`}( ) );

      get_obj( ).`{`$arg_gtffield`}( get_obj( ).`{`$arg_gffield`}( ) );
      get_obj( ).`{`$arg_gtfield`}( last_date_in_range );

      get_obj( ).op_apply( );
      transaction_commit( );
`{`!`@eq`(`$arg_genoutput`,`'`'`)
      if( !has_overlapping )
         // FUTURE: The output message itself should be a module string.
         `{`$arg_genoutput`} = events_name + " are ready for review and confirmation.";
      else
         // FUTURE: The output message itself should be a module string.
         `{`$arg_genoutput`} = "Note that one or more generated " + events_name + " are overlapping with each other.";\
`}
   }
   catch( ... )
   {
      get_obj( ).op_cancel( );
      transaction_rollback( );
      throw;
   }
   // [(finish for_schedule)]
`}
`{`@eq`(`'remproc`'`,`$section`)\
   // [(start for_schedule)]
   transaction_start( );
   try
   {
      get_obj( ).op_update( );

      string key_info( FIELD_ID( `{`$module_name`}, `{`$arg_eclass`}, `{`$arg_gnumfield`} ) );
      key_info += "#1 0";

      if( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_forwards( key_info ) )
      {
         do
         {
            get_obj( ).child_`{`$arg_eventchild`}( ).op_destroy( );
            get_obj( ).child_`{`$arg_eventchild`}( ).op_apply( );
         } while( get_obj( ).child_`{`$arg_eventchild`}( ).iterate_next( ) );
      }

      get_obj( ).`{`$arg_gffield`}( get_obj( ).`{`$arg_lgffield`}( ) );
      get_obj( ).`{`$arg_gtfield`}( get_obj( ).`{`$arg_lgtfield`}( ) );

      get_obj( ).`{`$arg_unrevfield`}( false );
      get_obj( ).`{`$arg_actsfield`}( string( c_procedure_id_`{`$arg_genproc`} ) );

      get_obj( ).op_apply( );
      transaction_commit( );
   }
   catch( ... )
   {
      get_obj( ).op_cancel( );
      transaction_rollback( );
      throw;
   }
   // [(finish for_schedule)]
`}
`{`@eq`(`'for_store`'`,`$section`)\
   // [(start for_schedule)]
   if( is_create )
      get_obj( ).`{`$arg_actsfield`}( c_procedure_id_`{`$arg_genproc`} );
   // [(finish for_schedule)]
`}
